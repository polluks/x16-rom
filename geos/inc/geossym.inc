; GEOS variable memory locations sorted by address
; reassembled by Maciej 'YTM/Alliance' Witkowiak

zpage           =       $00
;

;
r0              =       $02
r0L             =       $02
r0H             =       $03
r1              =       $04
r1L             =       $04
r1H             =       $05
r2              =       $06
r2L             =       $06
r2H             =       $07
r3              =       $08
r3L             =       $08
r3H             =       $09
r4              =       $0a
r4L             =       $0a
r4H             =       $0b
r5              =       $0c
r5L             =       $0c
r5H             =       $0d
r6              =       $0e
r6L             =       $0e
r6H             =       $0f
r7              =       $10
r7L             =       $10
r7H             =       $11
r8              =       $12
r8L             =       $12
r8H             =       $13
r9              =       $14
r9L             =       $14
r9H             =       $15
r10             =       $16
r10L            =       $16
r10H            =       $17
r11             =       $18
r11L            =       $18
r11H            =       $19
r12             =       $1a
r12L            =       $1a
r12H            =       $1b
r13             =       $1c
r13L            =       $1c
r13H            =       $1d
r14             =       $1e
r14L            =       $1e
r14H            =       $1f
r15             =       $20
r15L            =       $20
r15H            =       $21
;

.if 0
a0              =       $fb
a0L             =       $fb
a0H             =       $fc
a1              =       $fd
a1L             =       $fd
a1H             =       $fe
.else
; On GEOS64, a0/a1 are at $FB-$FE, which is documented
; as available on the C64.
; On the X16, these locations are occupied by BASIC.
; So legacy GEOS64 binaries, which will continue to use
; these locations, will overwrite BASIC's state, which
; is okay, because legacy apps don't need to coexist
; with BASIC.
; New applications will use the new addresses, which
; are otherwise unused on the X16.
a0              =       $6c
a0L             =       $6c
a0H             =       $6d
a1              =       $6e
a1L             =       $6e
a1H             =       $6f
.endif
a2              =       $70
a2L             =       $70
a2H             =       $71
a3              =       $72
a3L             =       $72
a3H             =       $73
a4              =       $74
a4L             =       $74
a4H             =       $75
a5              =       $76
a5L             =       $76
a5H             =       $77
a6              =       $78
a6L             =       $78
a6H             =       $79
a7              =       $7a
a7L             =       $7a
a7H             =       $7b
a8              =       $7c
a8L             =       $7c
a8H             =       $7d
a9              =       $7e
a9L             =       $7e
a9H             =       $7f

;

curPattern     = $22 ; [graph]
string         = $24 ; [conio]

g_baselineOffset = $26 ; [fonts; conio; menu]
g_curSetWidth  = $27 ; [fonts]
g_curHeight    = $29 ; [fonts; conio; menu]
g_curIndexTable= $2a ; [fonts; conio]
g_cardDataPntr = $2c ; [fonts; conio]
g_currentMode  = $2e ; [fonts; conio; menu; dlgbox]

dispBufferOn   = $2f ; [graph; fonts; conio; menu; dlgbox]

mouseOn        = $30 ; [mouse; menu; icon]
msePicPtr      = $31 ; unused on X16

g_windowTop    = $33 ; [fonts]
g_windowBottom = $34 ; [fonts]
g_leftMargin   = $35 ; [fonts; conio; menu]
g_rightMargin  = $37 ; [fonts; conio; menu; dlgbox]

pressFlag      = $39 ; [mouse; keyboard]
mouseXPos      = $3a ; [mouse; menu, icon; dlgbox]
mouseYPos      = $3c ; [mouse; menu, icon; dlgbox]
returnAddress  = $3d ; [misc]
graphMode      = $3f ; C128 only

curDevice      = $ba ; XXX X16 incorrect
;
irqvec         = $0314
bkvec          = $0316
nmivec         = $0318
;
APP_RAM        = $0400
PRINTBASE      = $7900
OS_VARS        = $8000
DISK_BASE      = $9000 ; files
OS_ROM         = $c000 ; ---
OS_JUMPTAB     = $c100 ; ---
NMI_VECTOR     = $fffa ; ---
RESET_VECTOR   = $fffc ; ---
IRQ_VECTOR     = $fffe ; ---
;

diskBlkBuf     = OS_VARS + $0000 ; Disk buffer #0 [drv, init, reu]
fileHeader     = OS_VARS + $0100 ; Disk buffer #1, Info sector [filesys]
curDirHead     = OS_VARS + $0200 ; Disk buffer #2, Directory work area [drv]
fileTrScTab    = OS_VARS + $0300 ; Disk buffer #3, Table of tracks and sectors [filesys, dlgbox]
dirEntryBuf    = OS_VARS + $0400 ; Current directory entry, set up by FindFile [filesys, init, tobasic]
DrACurDkNm     = OS_VARS + $041e ; Name of disk in drive 0 (device 8) [filesys]
DrBCurDkNm     = OS_VARS + $0430 ; Name of disk in drive 1 (device 9) [filesys]
dataFileName   = OS_VARS + $0442 ; Name of data file (passed to application) [filesys]
dataDiskName   = OS_VARS + $0453 ; Name of disk in drive 3 (device 11) [filesys]
PrntFilename   = OS_VARS + $0465 ; Name of current printer driver [---]
PrntDiskName   = OS_VARS + $0476 ; Name of disk containing printer driver [---]
curDrive       = OS_VARS + $0489 ; Current drive's device number [drv, filesys, boot]
diskOpenFlg    = OS_VARS + $048a ; ... [---]
isGEOS         = OS_VARS + $048b ; Format flag of current disk [drv]
interleave     = OS_VARS + $048c ; Skew factor for diskette operations [drv, boot]
numDrives      = OS_VARS + $048d ; Number of drive in the system [init, filesys, drv1541, boot]
driveType      = OS_VARS + $048e ; Whether a drive is a boot drive [drv, filesys, boot]
turboFlags     = OS_VARS + $0492 ; Drive status bytes [drv]
curRecord      = OS_VARS + $0496 ; Current VLIR chain number [filesys]
usedRecords    = OS_VARS + $0497 ; Number of VLIR chains in the open file [filesys]
fileWritten    = OS_VARS + $0498 ; Modified flag [filesys]
fileSize       = OS_VARS + $0499 ; VLIR file size [filesys]
appMain        = OS_VARS + $049b ; Vector for user additions to the GEOS main loop [mainloop, init, dlgbox]
intTopVector   = OS_VARS + $049d ; Vector for GEOS's IRQ routine [irq]
intBotVector   = OS_VARS + $049f ; Vector for a user's additions to the IRQ routine [irq]
mouseVector    = OS_VARS + $04a1 ; Vector for button status changes [mouse]
keyVector      = OS_VARS + $04a3 ; Vector for any key entered from the keyboard [dlgbox, conio, mouse]
inputVector    = OS_VARS + $04a5 ; Vector for mouse direction change [mouse]
mouseFaultVec  = OS_VARS + $04a7 ; Vector to close a menu [mouse]
otherPressVec  = OS_VARS + $04a9 ; ... [dlgbox, icon, mouse]
StringFaultVec = OS_VARS + $04ab ; Vector for margins exceeded [conio, menu, dlgbox]
alarmTmtVector = OS_VARS + $04ad ; Vector for the alarm clock routine [time]
BRKVector      = OS_VARS + $04af ; Vector for the BRK instruction [irq]
RecoverVector  = OS_VARS + $04b1 ; Vector for a routine to recover a region of the screen [menu]
selectionFlash = OS_VARS + $04b3 ; Default delay value for flashing boxes [menu, icon]
alphaFlag      = OS_VARS + $04b4 ; Text cursor flag [conio]
iconSelFlg     = OS_VARS + $04b5 ; Control flag for click box [icon]
faultData      = OS_VARS + $04b6 ; Mouse position flag [mouse]
menuNumber     = OS_VARS + $04b7 ; Number of menu levels [menu, lightpen, mouse]
mouseTop       = OS_VARS + $04b8 ; Top row of window [mouse, menu]
mouseBottom    = OS_VARS + $04b9 ; Bottom row of window [mouse]
mouseLeft      = OS_VARS + $04ba ; Left margin of window [mouse]
mouseRight     = OS_VARS + $04bc ; Right margin of window [mouse]
stringX        = OS_VARS + $04be ; Text cursor's X position [conio]
stringY        = OS_VARS + $04c0 ; Text cursor's Y position [conio]
mousePicData   = OS_VARS + $04c1 ; Sprite data for default mouse [init]
maxMouseSpeed  = OS_VARS + $0501 ; Maximum mouse speed [init, joydrv]
minMouseSpeed  = OS_VARS + $0502 ; Minimum mouse speed [init, joydrv]
mouseAccel     = OS_VARS + $0503 ; Mouse's acceleration rate [init, joydrv]
keyData        = OS_VARS + $0504 ; Next key from keyboard buffer [keyboard, conio, dlgbox]
mouseData      = OS_VARS + $0505 ; Current button status [input, dlgbox, mouse]
inputData      = OS_VARS + $0506 ; Mouse's current direction [input]
mouseSpeed     = OS_VARS + $0507 ; Current mouse speed [init, joydrv]
random         = OS_VARS + $050a ; Random number generator value [math]
saveFontTab    = OS_VARS + $050c ; Temporary storage for font data during menu processing [menu]
dblClickCount  = OS_VARS + $0515 ; ... [icon, irq]
year           = OS_VARS + $0516 ; Current year (0-99) [time, boot]
month          = OS_VARS + $0517 ; Current month [time, boot]
day            = OS_VARS + $0518 ; Current day of the month [time, boot]
hour           = OS_VARS + $0519 ; Current hour [time, boot]
minutes        = OS_VARS + $051a ; Current minute of the hour [time, boot]
seconds        = OS_VARS + $051b ; Current second of the minute [time, boot]
alarmSetFlag   = OS_VARS + $051c ; TRUE if alarm is set for GEOS to monitor [time]
sysDBData      = OS_VARS + $051d ; Command byte returned by the window processor [dlgbox]
screencolors   = OS_VARS + $051e ; Preferred screen colors [init]
dlgBoxRamBuf   = OS_VARS + $051f ; Temporary storage buffer for the window processor [dlgbox]
;             to OS_VARS + $0697

_driveType     = driveType-8
_turboFlags    = turboFlags-8

